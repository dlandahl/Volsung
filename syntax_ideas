
my_osc: osc~ 400        ; Make a thing {object?}
my_osc{0} -> {0}output  ; Connect a thing

; Inline arithmetic
white_noise: noise~
lowpass: lpf~ 400

cutoff -> *10 -> lpf{0}
lpf{0} -> noise{0}

modulator: osc~ 0.4

my_function(n): 7*n - 3^n
my_sequence: my_function(-5..5)

osc_bank_a: #5 ~osc my_function(n)
osc_bank_b: #5 ~osc my_function(2*n)

; Named inputs and outputs
modulator{0} <> osc_bank{'frequency'}
modulator{0} -> *0.5 -> +0.5 -> osc_bank[0]{'phase'}


thing: custom_object 200
x -> thing{0}

osc_bank{0} ~> osc_bank{0}



list: [1, 2, 3]
other_list: [list, [3, 4, 5]] !cat !rev
melody: seq~ [list, 10..20|2, [4, 3, 2], list] !cat

g(x): 2x + x^2 + 4
transform: func~ g

; Sequence processors:
; !cat
; !rev
; !interleave|other_sequence, third_sequence
; !insert|5, 3
; !sort
; !rep|n
; !loop|n
















infrared_noise (0, 1): [
	osc: noise~
	filters: [$1] filter~

	osc{0} -> filters[0]{0}
	filters{0} --> filters{0}

	filters[-1]{0} -> *100 -> out{0}
]


tone: osc~
noise: infrared_noise~ 5

file: file~ output.raw

noise{0} -> tone{0}
tone{0} -> file{0}

; =========================================

osc: noise~

corner: 5

a: filter~ corner
b: filter~ corner
c: filter~ corner
d: filter~ corner
e: filter~ corner

gain: mult~ 100000
offset: add~ 500

osc{0} -> a{0}
a{0} -> b{0}
b{0} -> c{0}
c{0} -> d{0}
d{0} -> e{0}

e{0} -> gain{0}
gain{0} -> offset{0}

tone: osc~
offset{0} -> tone{0}

file: file~ output.raw
tone{0} -> file{0}

; =========================================

chord: [4] saw~ 100*n

N: 20
Q: 4
transform(x): 40 * 2^x

carrier_bands: [N] bpf~ transform(n), Q
amps: [N] mult~

chord{0}         x> carrier_bands{0}
carrier_bands{0} => amps{0}


mod_bands: [N] bpf~ transform(n), Q
mod_followers: [N] env~ 20ms, 20ms

mod_bands{0}     => mod_followers{0}
mod_followers{0} => amps{1}

input{0} <> mod_bands{0}
amps{0}  >> output{0}


; =========================================





















major :: { 0, 2, 4, 5, 7, 9, 11, 12 }
f :: 440

scale_degree_to_frequency(frequency, scale, degree)	::
	frequency * (2^(1/12))^scale[degree - 1]

get_major_notes(d) :: scale_degree_to_frequency(f, major, d)

make_list(v, l) :: (0..10|10)[{0, 4, 3, 9, 9}] !rep l

pitches :: ({ 1, 3, 5 } !rep 5) * 2

clock :: clock~ sf / 6
disk ::  file~  "melody.raw"

clock(0)
	-> step~   pitches / 3
	-> filter~ 20
	-> osc~
	-> disk(0)





delay: (2, 1) {
	delay: ddl~ _1

	in|0
	-> delay
	-> mult~ 0.5
	-> delay
	-> 0|out
}
